#include "evaluation.h"
#include <cmath>
#include "board.h"

constexpr int PIECE_VALUES[] = {0, 100, 350, 350, 500, 1000, 20000};

constexpr int pawn_pst[8][8] = {
    {0,  0,  0,  0,  0,  0,  0,  0},
    {50, 50, 50, 50, 50, 50, 50, 50},
    {10, 10, 20, 30, 30, 20, 10, 10},
    {5,  5, 10, 25, 25, 10,  5,  5},
    {0,  0,  0, 20, 20,  0,  0,  0},
    {5, -5,-10,  0,  0,-10, -5,  5},
    {5, 10, 10,-20,-20, 10, 10,  5},
    {0,  0,  0,  0,  0,  0,  0,  0}
};

constexpr int knight_pst[8][8] = {
    {-50,-40,-30,-30,-30,-30,-40,-50},
    {-40,-20,  0,  0,  0,  0,-20,-40},
    {-30,  0, 10, 15, 15, 10,  0,-30},
    {-30,  5, 15, 20, 20, 15,  5,-30},
    {-30,  0, 15, 20, 20, 15,  0,-30},
    {-30,  5, 10, 15, 15, 10,  5,-30},
    {-40,-20,  0,  5,  5,  0,-20,-40},
    {-50,-40,-30,-30,-30,-30,-40,-50}
};

constexpr int bishop_pst[8][8] = {
    {-20,-10,-10,-10,-10,-10,-10,-20},
    {-10,  0,  0,  0,  0,  0,  0,-10},
    {-10,  0,  5, 10, 10,  5,  0,-10},
    {-10,  5,  5, 10, 10,  5,  5,-10},
    {-10,  0, 10, 10, 10, 10,  0,-10},
    {-10, 10, 10, 10, 10, 10, 10,-10},
    {-10,  5,  0,  0,  0,  0,  5,-10},
    {-20,-10,-10,-10,-10,-10,-10,-20}
};

constexpr int rook_pst[8][8] = {
    {0,  0,  0,  0,  0,  0,  0,  0},
    {5, 10, 10, 10, 10, 10, 10,  5},
    {-5, 0, 0, 0, 0, 0, 0, -5},
    {-5, 0, 0, 0, 0, 0, 0, -5},
    {-5, 0, 0, 0, 0, 0, 0, -5},
    {-5, 0, 0, 0, 0, 0, 0, -5},
    {-5, 0, 0, 0, 0, 0, 0, -5},
    {0,  0,  0,  5,  5,  0,  0,  0}
};

constexpr int queen_pst[8][8] = {
    {-20,-10,-10, -5, -5,-10,-10,-20},
    {-10,  0,  0,  0,  0,  0,  0,-10},
    {-10,  0,  5,  5,  5,  5,  0,-10},
    { -5,  0,  5,  5,  5,  5,  0, -5},
    {  0,  0,  5,  5,  5,  5,  0, -5},
    {-10,  5,  5,  5,  5,  5,  0,-10},
    {-10,  0,  5,  0,  0,  0,  0,-10},
    {-20,-10,-10, -5, -5,-10,-10,-20}
};

constexpr int mg_king_pst[8][8] = {
    {-30,-40,-40,-50,-50,-40,-40,-30},
    {-30,-40,-40,-50,-50,-40,-40,-30},
    {-30,-40,-40,-50,-50,-40,-40,-30},
    {-30,-40,-40,-50,-50,-40,-40,-30},
    {-20,-30,-30,-40,-40,-30,-30,-20},
    {-10,-20,-20,-20,-20,-20,-20,-10},
    {20, 20,  0,  0,  0,  0, 20, 20},
    {20, 30, 10,  0,  0, 10, 30, 20}
};

constexpr int eg_king_pst[8][8] = {
    {-50,-40,-30,-20,-20,-30,-40,-50},
    {-30,-20,-10,  0,  0,-10,-20,-30},
    {-30,-10, 20, 30, 30, 20,-10,-30},
    {-30,-10, 30, 40, 40, 30,-10,-30},
    {-30,-10, 30, 40, 40, 30,-10,-30},
    {-30,-10, 20, 30, 30, 20,-10,-30},
    {-30,-30,  0,  0,  0,  0,-30,-30},
    {-50,-30,-30,-30,-30,-30,-30,-50}
};

inline int abs_int(int x) {
    return x < 0 ? -x : x;
}

// Distance from center squares (3,3), (3,4), (4,3), (4,4)
int center_distance(int row, int col) {
    return std::abs(2 * row - 7) + std::abs(2 * col - 7);
}

// Distance between two squares
int manhattan_distance(int r1, int c1, int r2, int c2) {
    return std::abs(r1 - r2) + std::abs(c1 - c2);
}

bool is_endgame(const Board& board) {
    int whiteQueens = 0;
    int blackQueens = 0;
    int whiteRooks = 0;
    int blackRooks = 0;
    int whiteOther = 0; // non-pawn, non-king, non-queen pieces
    int blackOther = 0;
    int whiteMinors = 0; // knights + bishops
    int blackMinors = 0;

    for (int r = 0; r < 8; r++) {
        for (int c = 0; c < 8; c++) {
            int p = board.squares[r][c];
            if (p == 0) continue;
            int absP = abs_int(p);
            bool isWhite = (p > 0);

            if (absP == queen) {
                if (isWhite) whiteQueens++; else blackQueens++;
                continue;
            }
            if (absP == king || absP == pawn) continue;

            if (absP == rook) {
                if (isWhite) { whiteRooks++; whiteOther++; } else { blackRooks++; blackOther++; }
            } else if (absP == knight || absP == bishop) {
                if (isWhite) { whiteMinors++; whiteOther++; } else { blackMinors++; blackOther++; }
            } else {
                if (isWhite) whiteOther++; else blackOther++;
            }
        }
    }

    if (whiteQueens == 0 && blackQueens == 0) return true;

    if (whiteQueens > 0) {
        if (whiteRooks > 0) return false;
        if (whiteOther > 1) return false;
        if (whiteOther == 1 && whiteMinors != 1) return false;
    }
    if (blackQueens > 0) {
        if (blackRooks > 0) return false;
        if (blackOther > 1) return false;
        if (blackOther == 1 && blackMinors != 1) return false;
    }

    return true;
}

int evaluate_board(const Board& board) {
    int score = 0;
    constexpr int TEMPO_BONUS = 15; // centipawns awarded to side to move
    // Material tallies for endgame detection (merged into main scan)
    int whiteQueens = 0, blackQueens = 0;
    int whiteRooks = 0, blackRooks = 0;
    int whiteOther = 0, blackOther = 0; // non-pawn, non-king, non-queen pieces
    int whiteMinors = 0, blackMinors = 0;

    // Phase-dependent king scores (computed once, applied after endgame decision)
    int whiteKingMgScore = 0, whiteKingEgScore = 0;
    int blackKingMgScore = 0, blackKingEgScore = 0;

    int whitesBlackBishop = 0;
    int whitesWhiteBishop = 0;
    int blacksBlackBishop = 0;
    int blacksWhiteBishop = 0;
    bool isOpening = false;
    bool isMidgame = false;
    int totalPieces = 0;

    for (int row = 0; row < 8; row++) {
        for (int column = 0; column < 8; column++) {
            if (board.squares[row][column] != 0) totalPieces++;
            isOpening = (totalPieces >= 28); // 28+ pieces = opening 
            isMidgame = (totalPieces >= 16 && totalPieces < 28);
            int p = board.squares[row][column];
            if (p == 0) continue;
            int absPiece = abs_int(p);
            int sign = (p > 0) ? 1 : -1;

            // Material
            score += sign * PIECE_VALUES[absPiece];

            // PST contribution â€” flip for black by using mirrored row
            int pr = (p > 0) ? row : 7 - row;
            switch (absPiece) {
                case pawn:
                {
                    score += (p > 0) ? pawn_pst[row][column] : -pawn_pst[pr][column];
                    bool isolated = true;
                    if (column > 0) {
                        for (int rr = 0; rr < 8; rr++) {
                            int leftPiece = board.squares[rr][column-1];
                            if (abs_int(leftPiece) == pawn && (leftPiece > 0) == (p > 0)) {
                                isolated = false;
                                break;
                            }
                        }
                    }
                    if (column < 7) {
                        for (int rr = 0; rr < 8; rr++) {
                            int rightPiece = board.squares[rr][column+1];
                            if (abs_int(rightPiece) == pawn && (rightPiece > 0) == (p > 0)) {
                                isolated = false;
                                break;
                            }
                        }
                    }
                    if (isolated) {
                        score += (p > 0) ? -15 : 15; // isolated pawn is bad
                    }

                    // Doubled pawns penalty
                    for (int rr = row+1; rr < 8; rr++) {
                        if (board.squares[rr][column] == p) {
                            score += (p > 0) ? -20 : 20; // Doubled pawns are bad
                            break;
                        }
                    }
                    bool passed = true;
                    int direction = (p > 0) ? -1 : 1;

                    // Opposing pawns ahead on adjacent files block passed-pawn status.
                    for (int checkCol = std::max(0, column - 1); checkCol <= std::min(7, column + 1); checkCol++) {
                        for (int rr = row + direction; rr >= 0 && rr < 8; rr += direction) {
                            int checkPiece = board.squares[rr][checkCol];
                            if (checkPiece == -p) { // opponent pawn
                                passed = false;
                                break;
                            }
                        }
                        if (!passed) break;
                    }

                    // If any piece blocks the path on this file, dampen the bonus.
                    bool path_blocked = false;
                    for (int rr = row + direction; rr >= 0 && rr < 8; rr += direction) {
                        if (board.squares[rr][column] != 0) {
                            path_blocked = true;
                            break;
                        }
                    }

                    if (passed) {
                        int rank = (p > 0) ? (7 - row) : row;
                        int bonus = rank * rank * 8; // softer growth to avoid over-valuing stuck pawns
                        if (path_blocked) {
                            bonus /= 4; // heavily discount if it cannot currently advance
                        }
                        score += (p > 0) ? bonus : -bonus;
                    }
                    break;
                }
                case knight:
                    score += (p > 0) ? knight_pst[row][column] : -knight_pst[pr][column];
                    if (p > 0) { whiteMinors++; whiteOther++; } else { blackMinors++; blackOther++; }
                    break;
                case bishop:
                {
                    bool isLightSquare = ((row + column) % 2 == 0) ? true : false; 
                    if (p > 0) {
                        if (isLightSquare) whitesWhiteBishop++;
                        else whitesBlackBishop++;
                        score += bishop_pst[row][column];
                        whiteMinors++; whiteOther++;
                    } 
                    else {
                        if (isLightSquare) blacksWhiteBishop++;
                        else blacksBlackBishop++;
                        score -= bishop_pst[pr][column];
                        blackMinors++; blackOther++;
                    }

                    int forward = (p > 0) ? -1 : 1;
                    int frontRow = row + forward;
                    if (frontRow >= 0 && frontRow < 8) {
                        if (column - 1 >= 0) { // left diagonal
                            int blockingPiece1 = board.squares[frontRow][column - 1];
                            if (abs_int(blockingPiece1) == pawn && (blockingPiece1 > 0) == (p > 0)) {
                                score += (p > 0) ? -20 : 20;
                            }
                        }

                        if (column + 1 < 8) { // right diagonal
                            int blockingPiece2 = board.squares[frontRow][column + 1];
                            if (abs_int(blockingPiece2) == pawn && (blockingPiece2 > 0) == (p > 0)) {
                                score += (p > 0) ? -20 : 20;
                            }
                        }
                    }
                    break;
                }
                case rook:
                {
                    score += (p > 0) ? rook_pst[row][column] : -rook_pst[pr][column];
                    if (p > 0) { whiteRooks++; whiteOther++; } else { blackRooks++; blackOther++; }
                    bool openFile = true;
                    bool semiOpenFile = true;
                    for (int rr = 0; rr < 8; rr++) {
                        int pieceOnFile = board.squares[rr][column];
                        if (pieceOnFile != 0) {
                            int absPiece = abs_int(pieceOnFile);
                            if (absPiece == pawn) {
                                if ((pieceOnFile > 0) == (p > 0)) {
                                    // you got your own pawn on the file
                                    semiOpenFile = false;
                                    openFile = false;
                                } else {
                                    // opponent's pawn on the file
                                    openFile = false;
                                }
                            }
                        }
                    }
                    
                    if (openFile) {
                        score += (p > 0) ? 50 : -50; // Open file is very valuable
                    } else if (semiOpenFile) {
                        score += (p > 0) ? 25 : -25; // Semi open file is also good
                    }
                    // Connected rooks bonus
                    for (int r = 0; r < 8; r++) {
                        for (int c = 0; c < 8; c++) {
                            int p = board.squares[r][c];
                            if (abs_int(p) != rook) continue;
                            
                            // Any same file rook?
                            for (int rr = r + 1; rr < 8; rr++) {
                                int other = board.squares[rr][c];
                                if (other == p) { // Same color rook
                                    // Are there any pieces between them?
                                    bool connected = true;
                                    for (int between = r + 1; between < rr; between++) {
                                        if (board.squares[between][c] != 0) {
                                            connected = false;
                                            break;
                                        }
                                    }
                                    if (connected) {
                                        score += (p > 0) ? 30 : -30;
                                    }
                                }
                            }
                            
                            // Checking the same rank
                            for (int cc = c + 1; cc < 8; cc++) {
                                int other = board.squares[r][cc];
                                if (other == p) { // Same color rook
                                    // Are there any pieces between them?
                                    bool connected = true;
                                    for (int between = c + 1; between < cc; between++) {
                                        if (board.squares[r][between] != 0) {
                                            connected = false;
                                            break;
                                        }
                                    }
                                    if (connected) {
                                        score += (p > 0) ? 30 : -30;
                                    }
                                }
                            }

                        }
                    }

                    break;
                }
                case queen:
                    score += (p > 0) ? queen_pst[row][column] : -queen_pst[pr][column];
                    if (p > 0) whiteQueens++; else blackQueens++;
                    break;
                case king:
                    {
                        double centerDist = std::abs(row - 3.5) + std::abs(column - 3.5);
                        if (p > 0) {
                            whiteKingMgScore = mg_king_pst[row][column];
                            whiteKingEgScore = eg_king_pst[row][column] + static_cast<int>((7 - centerDist) * 5);
                        } else {
                            blackKingMgScore = -mg_king_pst[pr][column];
                            blackKingEgScore = -eg_king_pst[pr][column] - static_cast<int>((7 - centerDist) * 5);
                        }
                        break;
                    }
            }
        }
    }

    // Decide phase once using tallied material
    bool endgame = true;
    if (whiteQueens > 0) {
        if (!(whiteRooks == 0 && (whiteOther <= 1) && (whiteOther == 0 || whiteMinors == 1))) {
            endgame = false;
        }
    }
    if (blackQueens > 0) {
        if (!(blackRooks == 0 && (blackOther <= 1) && (blackOther == 0 || blackMinors == 1))) {
            endgame = false;
        }
    }

    // Apply king scores now that phase is known
    score += endgame ? (whiteKingEgScore + blackKingEgScore) : (whiteKingMgScore + blackKingMgScore);

    if (endgame && (score > 200 || score < -200)) {  
        bool whiteWinning = (score > 0);
        int winningKingRow = whiteWinning ? board.whiteKingRow : board.blackKingRow;
        int winningKingCol = whiteWinning ? board.whiteKingCol : board.blackKingCol;
        int losingKingRow  = whiteWinning ? board.blackKingRow : board.whiteKingRow;
        int losingKingCol  = whiteWinning ? board.blackKingCol : board.whiteKingCol;
        
        int enemyDistFromCenter = center_distance(losingKingRow, losingKingCol);
        
        int distanceBetweenKings = manhattan_distance(
            winningKingRow, winningKingCol, 
            losingKingRow, losingKingCol
        );
        
        int mopUpScore = 0;
        mopUpScore += enemyDistFromCenter * 10;
        mopUpScore += (14 - distanceBetweenKings) * 5;
        
        score += whiteWinning ? mopUpScore : -mopUpScore;
    }

    // protect the pawns in front of the king
    if (isMidgame || isOpening) {
        int wKingFile = board.whiteKingCol;
        int wKingRank = board.whiteKingRow;
        int pawnShield = 0;
        
        // count pawns in front of the white king
        for (int dc = -1; dc <= 1; dc++) {
            int column = wKingFile + dc;
            if (column < 0 || column >= 8) continue;
            
            // 2nd and 3rd ranks have pawns?
            if (board.squares[6][column] == pawn) pawnShield += 20; // Right in front
            else if (board.squares[5][column] == pawn) pawnShield += 10; // One square ahead
        }
        
        score += pawnShield;
        
        // Same for black king
        int bKingFile = board.blackKingCol;
        int blackPawnShield = 0;
        for (int dc = -1; dc <= 1; dc++) {
            int column = bKingFile + dc;
            if (column < 0 || column >= 8) continue;
            if (board.squares[1][column] == -pawn) blackPawnShield += 20;
            else if (board.squares[2][column] == -pawn) blackPawnShield += 10;
        }
        
        score -= blackPawnShield;

        // Penalty for open files next to king
        int openFilePenalty = 0;
        for (int dc = -1; dc <= 1; dc++) {
            int column = wKingFile + dc;
            if (column < 0 || column >= 8) continue;
            
            bool hasOwnPawn = false;
            for (int r = 0; r < 8; r++) {
                if (board.squares[r][column] == pawn) {
                    hasOwnPawn = true;
                    break;
                }
            }
            
            if (!hasOwnPawn) {
                // Open file next to king is dangerous
                openFilePenalty += 50;
            }
        }
        int queenThreat = 0;
        // Find enemy queen
        for (int r = 0; r < 8; r++) {
            for (int c = 0; c < 8; c++) {
                if (board.squares[r][c] == -queen) {
                    // Calculate distance to white king
                    int distance = std::abs(r - wKingRank) + std::abs(c - wKingFile);
                    if (distance <= 3) {
                        // Enemy queen is VERY close to king
                        queenThreat += (4 - distance) * 40; // Closer = worse
                    }
                }
            }
        }
        
        int backRankPenalty = 0;
        if (wKingRank == 7) { // White king on back rank
            bool trapped = true;
            // Check if king can move forward
            if (board.squares[6][wKingFile] == 0) {
                trapped = false;
            }
            if (trapped) {
                backRankPenalty = 60; // Trapped on back rank
            }
        }
        
        score += pawnShield;
        score -= openFilePenalty;
        score -= queenThreat;
        score -= backRankPenalty;
        
        // Same for black king (mirror)
        int bKingRank = board.blackKingRow;
        for (int dc = -1; dc <= 1; dc++) {
            int column = bKingFile + dc;
            if (column < 0 || column >= 8) continue;
            if (board.squares[1][column] == -pawn) blackPawnShield += 20;
            else if (board.squares[2][column] == -pawn) blackPawnShield += 10;
        }
        
        int blackOpenFilePenalty = 0;
        for (int dc = -1; dc <= 1; dc++) {
            int column = bKingFile + dc;
            if (column < 0 || column >= 8) continue;
            bool hasOwnPawn = false;
            for (int r = 0; r < 8; r++) {
                if (board.squares[r][column] == -pawn) {
                    hasOwnPawn = true;
                    break;
                }
            }
            if (!hasOwnPawn) {
                blackOpenFilePenalty += 50;
            }
        }
        
        int blackQueenThreat = 0;
        for (int r = 0; r < 8; r++) {
            for (int c = 0; c < 8; c++) {
                if (board.squares[r][c] == queen) {
                    int distance = std::abs(r - bKingRank) + std::abs(c - bKingFile);
                    if (distance <= 3) {
                        blackQueenThreat += (4 - distance) * 40;
                    }
                }
            }
        }
        
        int blackBackRankPenalty = 0;
        if (bKingRank == 0) {
            bool trapped = true;
            if (board.squares[1][bKingFile] == 0) {
                trapped = false;
            }
            if (trapped) {
                blackBackRankPenalty = 60;
            }
        }
        
        score -= blackPawnShield;
        score += blackOpenFilePenalty;
        score += blackQueenThreat;
        score += blackBackRankPenalty;
    }

    if (whitesWhiteBishop >= 1 && whitesBlackBishop >= 1) {
        score += endgame ? 60 : 30;
    }
    if (blacksWhiteBishop >= 1 && blacksBlackBishop >= 1) {
        score -= endgame ? 60 : 30;
    }

    if (!endgame) { // center control in opening/midgame
        int whiteCenterPawns = 0;
        int blackCenterPawns = 0;
        
        // Direct center pawn occupation
        if (board.squares[4][4] == pawn) whiteCenterPawns += 40; // e4
        if (board.squares[4][3] == pawn) whiteCenterPawns += 40; // d4
        if (board.squares[3][4] == -pawn) blackCenterPawns += 40; // e5
        if (board.squares[3][3] == -pawn) blackCenterPawns += 40; // d5
        
        // Extended center (c4, c5, f4, f5)
        if (board.squares[4][2] == pawn) whiteCenterPawns += 25; // c4
        if (board.squares[4][5] == pawn) whiteCenterPawns += 25; // f4
        if (board.squares[3][2] == -pawn) blackCenterPawns += 25; // c5
        if (board.squares[3][5] == -pawn) blackCenterPawns += 25; // f5
        
        score += whiteCenterPawns - blackCenterPawns;
    }
    score += board.isWhiteTurn ? TEMPO_BONUS : -TEMPO_BONUS; // static tempo bonus
    return score;
}

int repetition_draw_score(const Board& board) {
    int currentScore = evaluate_board(board);
    if (!board.isWhiteTurn) currentScore = -currentScore;
    
    // if my position is clearly better, then a draw is bad
    if (currentScore > 100) return -50; 
    
    // if my position is clearly worse, then a draw is good
    return 0;
}