#include "board.h"
#include "search.h"
#include <iostream>
#include <string>
#include <sstream>
#include <chrono>
#include <vector>
#include <algorithm>

void bench() {
    // 1. Standart Test Pozisyonları (Stockfish'in kullandıkları)
    std::vector<std::string> fens = {
        "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",  // Başlangıç
        "r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - 0 1", // Karmaşık (KiwiPete)
        "8/2p5/3p4/KP5r/1R3p1k/8/4P1P1/8 w - - 0 1", // Oyun sonu
        "r3k2r/Pppp1ppp/1b3nbN/nP6/BBP1P3/q4N2/Pp1P2PP/R2Q1RK1 w kq - 0 1" // Taktik
    };

    long long totalNodes = 0;
    long long totalTimeMs = 0;
    Board board;
    transpositionTable.clear();

    for (const auto& fen : fens) {
        board.loadFromFEN(fen);
        std::vector<uint64_t> history;
        history.reserve(256);
        history.push_back(position_key(board));

        resetNodeCounter();

        auto startTime = std::chrono::steady_clock::now();
        Move best = getBestMove(board, 5, -1, history);
        auto endTime = std::chrono::steady_clock::now();

        long long elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
        long long nodes = getNodeCounter();

        totalNodes += nodes;
        totalTimeMs += elapsed;

        std::cout << "info string bench fen nodes " << nodes
                  << " time " << elapsed << "ms nps "
                  << (nodes * 1000 / (elapsed + 1))
                  << " best " << columns[best.fromCol] << (8 - best.fromRow)
                  << columns[best.toCol] << (8 - best.toRow) << std::endl;
    }

    long long benchDuration = std::max<long long>(1, totalTimeMs);
    std::cout << totalNodes << " nodes " 
              << (totalNodes * 1000 / benchDuration) << " nps" << std::endl;
    std::cout << "Bench: " << totalNodes << std::endl;
}

int main(int argc, char* argv[]) {
    
    if (argc > 1 && std::string(argv[1]) == "bench") {
        bench();
        return 0;
    }

    Board board;
    std::vector<uint64_t> gameHistory;
    gameHistory.reserve(512);
    std::string line;

    // Normal UCI döngüsü buradan devam eder...
    while (std::getline(std::cin, line)) {
        
        if (line == "uci") {
            std::cout << "id name SoloBot" << std::endl;
            std::cout << "id author xsolod3v" << std::endl;
            std::cout << "option name Hash type spin default 16 min 1 max 2048" << std::endl;
            std::cout << "option name Threads type spin default 1 min 1 max 1" << std::endl;
            std::cout << "uciok" << std::endl;
        }
        
        else if (line == "isready") {
            std::cout << "readyok" << std::endl;
        }

        else if (line == "bench") {
            bench();
        }
        
        else if (line.substr(0, 8) == "position") {
            if (line.find("startpos") != std::string::npos) {
                board.resetBoard();
            }
            else if (line.find("fen") != std::string::npos) {
                size_t fenStart = line.find("fen") + 4;
                size_t movesPos = line.find("moves");
                std::string fenStr;
                if (movesPos != std::string::npos) {
                    fenStr = line.substr(fenStart, movesPos - fenStart);
                } else {
                    fenStr = line.substr(fenStart);
                }
                board.loadFromFEN(fenStr);
            }
            gameHistory.clear();
            gameHistory.push_back(position_key(board));
            
            size_t movesPos = line.find("moves");
            if (movesPos != std::string::npos) {

                std::string movesStr = line.substr(movesPos + 6);
                std::stringstream ss(movesStr);
                std::string moveToken;
                
                while (ss >> moveToken) {
                    Move m = uci_to_move(moveToken);
                    board.makeMove(m);
                    gameHistory.push_back(position_key(board));
                }
            }
        }
        
        if (line.substr(0, 2) == "go") {
            int depth = 6;
            int movetime = -1;
            {
                std::stringstream ss(line);
                std::string token;
                ss >> token; 
                while (ss >> token) {
                    if (token == "depth") {
                        int parsed = 0;
                        if (ss >> parsed) depth = parsed;
                    }
                    else if (token == "movetime") {
                        ss >> movetime;
                    }
                }
            }
            
            if (movetime > 0) {
                depth = 128;
            }
            
            if (transpositionTable.size() > 20000000) { 
                transpositionTable.clear(); 
                std::cout << "info string TT full, clearing memory..." << std::endl;
            }
            Move best = getBestMove(board, depth, movetime, gameHistory);
            
            std::cout << "bestmove " << columns[best.fromCol] << (8 - best.fromRow) 
                 << columns[best.toCol] << (8 - best.toRow);
            
            if (best.promotion != 0) {
                switch (abs(best.promotion)) {
                    case queen: std::cout << 'q'; break;
                    case rook: std::cout << 'r'; break;
                    case bishop: std::cout << 'b'; break;
                    case knight: std::cout << 'n'; break;
                }
            }
            std::cout << std::endl;
        }
        
        else if (line == "quit") {
            break;
        }
    }
    return 0;
}